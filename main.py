# -*- coding: utf-8 -*-
"""main.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YHRkbxytMjllXEZSVAMZHn3NLzwczewS
"""

from google.colab import drive
drive.mount('/content/drive')

import os
import pandas as pd
import numpy as np
import pickle
from sentence_transformers import SentenceTransformer

# Load dataset
df = pd.read_parquet("/content/drive/MyDrive/Datasets/IKEA/train-00000-of-00001.parquet")

# File paths
embedding_file = "/content/cached_embeddings.npy"
description_file = "/content/descriptions.pkl"

def compute_embeddings(texts, model):
    return model.encode(texts, convert_to_numpy=True)

# Load or initialize model
model = SentenceTransformer("all-MiniLM-L6-v2")

if os.path.exists(embedding_file) and os.path.exists(description_file):
    print("Loading cached embeddings and descriptions...")
    embeddings = np.load(embedding_file)
    with open(description_file, "rb") as f:
        descriptions = pickle.load(f)
else:
    print("Computing embeddings for the first time...")
    descriptions = df["desc"].astype(str).tolist()
    embeddings = compute_embeddings(descriptions, model)

    # Save for future use
    np.save(embedding_file, embeddings)
    with open(description_file, "wb") as f:
        pickle.dump(descriptions, f)

    print("Embeddings and descriptions saved.")

print("Embeddings ready! Future runs will be much faster.")

!pip install faiss-cpu

import os
import numpy as np
import faiss
from sentence_transformers import SentenceTransformer
from IPython.display import display, Image
import pickle

# Load the model for generating text embeddings
model = SentenceTransformer('all-MiniLM-L6-v2')

# Define dataset paths
dataset_path = "/content/drive/MyDrive/Datasets/IKEA_Images"
embedding_path = "/content/drive/MyDrive/Datasets/cached_embeddings.npy"
descriptions_path = "/content/drive/MyDrive/Datasets/descriptions.pkl"

# Load room descriptions
with open(descriptions_path, "rb") as f:
    room_descriptions = pickle.load(f)

# Load room embeddings
if os.path.exists(embedding_path):
    room_embeddings = np.load(embedding_path)
    print("[INFO] Room embeddings loaded.")
else:
    print("[ERROR] Embedding file not found!")

# Load image paths
image_folder = os.path.join(dataset_path, "images", "room_scenes")
room_images = [os.path.join(image_folder, img) for img in os.listdir(image_folder) if img.endswith(".jpg")]

print(f"Total room descriptions: {len(room_descriptions)}")
print(f"Total room embeddings: {room_embeddings.shape[0]}")
print(f"Total room images available: {len(room_images)}")

# Check alignment
if len(room_descriptions) != room_embeddings.shape[0]:
    print("[ERROR] Mismatch between descriptions and embeddings!")

if len(room_images) < len(room_descriptions):
    print("[WARNING] Fewer images than descriptions! Some rooms may not have images.")

import os
import pickle

data_path = "/content/drive/MyDrive/Datasets"  # replace if needed
file_path = os.path.join(data_path, 'IKEA_Images', 'text_data', 'img_to_desc.p')

with open(file_path, 'rb') as f:
    data = pickle.load(f)

print(data)

import os
import numpy as np
import pandas as pd
import pickle
import torch
from sklearn.metrics.pairwise import cosine_similarity
from transformers import AutoTokenizer, AutoModel
import random
import requests
from PIL import Image
from io import BytesIO
import matplotlib.pyplot as plt
import json

class InteriorDesignAI:
    def __init__(self, data_path, model_name="sentence-transformers/all-MiniLM-L6-v2", device=None,
                 google_api_key=None, google_cse_id=None):
        """
        Initialize the Interior Design AI system
        """
        self.data_path = data_path
        self.model_name = model_name
        self.device = device if device else ('cuda' if torch.cuda.is_available() else 'cpu')
        self.google_api_key = google_api_key
        self.google_cse_id = google_cse_id

        self.tokenizer = AutoTokenizer.from_pretrained(model_name)
        self.model = AutoModel.from_pretrained(model_name).to(self.device)

        self.load_datasets()

    def search_furniture_image(self, furniture_description, brand=None):
        if self.google_api_key and self.google_cse_id:
            search_query = furniture_description
            if brand:
                search_query = f"{brand} {search_query}"

            search_url = "https://www.googleapis.com/customsearch/v1"
            params = {
                'q': search_query,
                'key': self.google_api_key,
                'cx': self.google_cse_id,
                'searchType': 'image',
                'num': 1
            }

            try:
                response = requests.get(search_url, params=params)
                results = response.json()

                if 'items' in results and len(results['items']) > 0:
                    return results['items'][0]['link']
            except Exception as e:
                print(f"Error searching for image: {e}")

        return self.get_placeholder_image(furniture_description)

    def get_placeholder_image(self, description):
        keywords = {
            "bed": "bed-furniture",
            "sofa": "sofa",
            "chair": "chair",
            "table": "table",
            "desk": "desk",
            "nightstand": "nightstand",
            "dresser": "dresser",
            "bookcase": "bookcase",
            "shelf": "bookshelf",
            "cabinet": "cabinet",
            "coffee table": "coffee-table",
            "dining": "dining-table"
        }

        search_term = "furniture"
        for keyword, term in keywords.items():
            if keyword.lower() in description.lower():
                search_term = term
                break

        return f"https://source.unsplash.com/featured/?{search_term}"

    def display_furniture_image(self, furniture_description, img_url=None):
        if not img_url:
            img_url = self.search_furniture_image(furniture_description)

        if img_url:
            try:
                response = requests.get(img_url)
                img = Image.open(BytesIO(response.content))

                plt.figure(figsize=(8, 8))
                plt.imshow(img)
                plt.title(furniture_description)
                plt.axis('off')
                plt.show()
                return True
            except Exception as e:
                print(f"Error displaying image: {e}")

        print(f"Could not display image for: {furniture_description}")
        return False

    def display_room_layout_with_images(self, layout):
        print(f"\n----- Room Layout ({layout['room_dimensions']['width']}m × {layout['room_dimensions']['length']}m) -----")
        print("\nFurniture Placement:")
        for idx, item in enumerate(layout['furniture_placement']):
            print(f"\n{idx+1}. {item['description']}")
            print(f"  Position: ({item['position']['x']:.2f}m, {item['position']['y']:.2f}m)")
            print(f"  Dimensions: {item['dimensions']['width']}m × {item['dimensions']['length']}m × {item['dimensions']['height']}m")
            if 'style_score' in item:
                print(f"  Style Match: {item['style_score']:.2f}")
            if 'image_url' in item and item['image_url']:
                self.display_furniture_image(item['description'], item['image_url'])
            else:
                self.display_furniture_image(item['description'])

    def __init__(self, data_path, model_name="sentence-transformers/all-MiniLM-L6-v2", device=None):
        """
        Initialize the Interior Design AI system

        Args:
            data_path (str): Path to the dataset directory
            model_name (str): Name of the transformer model to use for embeddings
            device (str): Device to use for model computations ('cpu' or 'cuda')
        """
        self.data_path = data_path
        self.model_name = model_name
        self.device = device if device else ('cuda' if torch.cuda.is_available() else 'cpu')

        # Load tokenizer and model for text embeddings
        self.tokenizer = AutoTokenizer.from_pretrained(model_name)
        self.model = AutoModel.from_pretrained(model_name).to(self.device)

        # Load datasets
        self.load_datasets()

    def load_datasets(self):
        """Load all necessary datasets and embeddings"""
        # Load furniture data
        try:
            self.furniture_embeddings = np.load(os.path.join(self.data_path, 'cached_embeddings.npy'))
            print("Loaded cached embeddings")
        except FileNotFoundError:
            print("Cached embeddings not found, will compute on the fly")
            self.furniture_embeddings = None

        # Load furniture descriptions
        self.furniture_descriptions = self._load_pickle('descriptions.pkl', {})
        print(f"Furniture Descriptions: {len(self.furniture_descriptions)} items loaded")

        # Load room-to-item mappings
        self.room_to_item = self._load_pickle(os.path.join('IKEA_Images', 'text_data', 'room_to_items.p'), {})
        print(f"Room-to-Item Mappings: {len(self.room_to_item)} rooms loaded")

        # Load item-to-room mappings
        self.item_to_room = self._load_pickle(os.path.join('IKEA_Images', 'text_data', 'item_to_room.p'), {})
        print(f"Item-to-Room Mappings: {len(self.item_to_room)} items loaded")

        # Load product dimensions
        self.product_dimensions = self._load_pickle(os.path.join('IKEA_Images', 'text_data', 'products_dict.p'), {})
        print(f"Product Dimensions: {len(self.product_dimensions)} items loaded")

        # Load categories data
        self.categories_data = self._load_pickle(os.path.join('IKEA_Images', 'text_data', 'categories_dict.p'), {})
        print(f"Categories Data: {len(self.categories_data)} categories loaded")

        # Load image mappings
        self.img_to_description = self._load_pickle(os.path.join('IKEA_Images', 'text_data', 'img_to_desc.p'), {})
        print(f"Image Descriptions: {len(self.img_to_description)} images loaded")

        # Load additional data if needed
        self.parquet_data = self._load_parquet('data.parquet', pd.DataFrame())
        print(f"Parquet Data: {len(self.parquet_data)} rows loaded")

        self.data_pkl = self._load_pickle('data.pkl', None)
        print(f"Data PKL: {'Loaded' if self.data_pkl is not None else 'Not loaded'}")

    def _load_pickle(self, file_path, default=None):
        """Helper function to load pickle files"""
        try:
            with open(os.path.join(self.data_path, file_path), 'rb') as f:
                return pickle.load(f)
        except FileNotFoundError as e:
            print(f"Error loading {file_path}: {e}")
            return default

    def _load_parquet(self, file_path, default=None):
        """Helper function to load parquet files"""
        try:
            return pd.read_parquet(os.path.join(self.data_path, file_path))
        except FileNotFoundError as e:
            print(f"Error loading {file_path}: {e}")
            return default

    def get_embedding(self, text):
        """
        Get embedding for a text using the transformer model

        Args:
            text (str): Input text

        Returns:
            numpy.ndarray: Embedding vector
        """
        inputs = self.tokenizer(text, return_tensors="pt", padding=True, truncation=True, max_length=512)
        inputs = {key: value.to(self.device) for key, value in inputs.items()}
        with torch.no_grad():
            outputs = self.model(**inputs)

        # Mean pooling
        token_embeddings = outputs.last_hidden_state
        attention_mask = inputs['attention_mask']
        input_mask_expanded = attention_mask.unsqueeze(-1).expand(token_embeddings.size()).float()
        embedding = torch.sum(token_embeddings * input_mask_expanded, 1) / torch.clamp(input_mask_expanded.sum(1), min=1e-9)

        return embedding.cpu().numpy()[0]

    def get_furniture_by_style(self, room_type, style_attributes, base_furniture=None):
      # Create a style query by combining the style attributes and room type
      style_query = f"{' '.join(style_attributes)} {room_type} furniture"
      print(f"Style query: '{style_query}'")

      # Get embedding for the style query
      style_embedding = self.get_embedding(style_query)

      # Start with any base furniture or get suitable items for the room type
      furniture_pool = base_furniture if base_furniture else self.get_suitable_furniture(room_type)

      # If we still don't have furniture, use defaults
      if not furniture_pool:
          furniture_pool = self.get_default_furniture(room_type)

      # For each furniture item, compute style similarity
      style_matched_items = []

      for item in furniture_pool:
          # Get the item description
          item_desc = item['description']

          # Combine with style for embedding
          item_style_desc = f"{item_desc} {' '.join(style_attributes)}"

          # Get embedding
          try:
              item_embedding = self.get_embedding(item_style_desc)

              # Compute similarity
              similarity = cosine_similarity([style_embedding], [item_embedding])[0][0]

              # Add similarity score to the item
              item_with_score = item.copy()
              item_with_score['style_score'] = float(similarity)
              style_matched_items.append(item_with_score)
          except Exception as e:
              print(f"Error calculating embedding for item '{item_desc}': {e}")
              # Add item without score
              item_with_score = item.copy()
              item_with_score['style_score'] = 0.0
              style_matched_items.append(item_with_score)

      # Sort by style score
      style_matched_items.sort(key=lambda x: x.get('style_score', 0), reverse=True)

      # Get the top items (at least 5, at most all)
      num_items = max(5, min(len(style_matched_items), 10))
      top_items = style_matched_items[:num_items]

      print(f"Selected {len(top_items)} style-matched items")
      return top_items

    def get_default_furniture_by_style(self, room_type, style_attributes):
      """
      Get default furniture with style considerations

      Args:
          room_type (str): Type of room
          style_attributes (list): Style descriptors

      Returns:
          list: Styled default furniture
      """
      # Get base default furniture
      default_items = self.get_default_furniture(room_type)

      # Apply style modifiers to descriptions
      style_str = " ".join(style_attributes)
      styled_items = []

      for item in default_items:
          styled_desc = f"{style_str} {item['description']}"
          styled_item = item.copy()
          styled_item['description'] = styled_desc
          styled_items.append(styled_item)

      return styled_items


    def suggest_room_layout_with_style(self, room_request, room_size, fetch_images=False):

      """
      Suggest a room layout based on a descriptive room request with style

      Args:
          room_request (str): Descriptive room request (e.g., "modern study room that is light")
          room_size (dict): Room dimensions (width, length in meters)

      Returns:
          dict: Suggested room layout with furniture placement
      """
      # Parse the room request
      room_type, style_attributes = self.parse_room_request(room_request)
      print(f"Parsed request: Room type = '{room_type}', Style attributes = {style_attributes}")

      # Get basic furniture for the room type
      base_furniture = self.get_suitable_furniture(room_type)

      # If we have style attributes, filter or enhance with style-specific furniture
      if style_attributes:
          styled_furniture = self.get_furniture_by_style(room_type, style_attributes, base_furniture)
      else:
          styled_furniture = base_furniture

      # Create and return the layout
      layout = self.create_layout(room_size, styled_furniture)
      if fetch_images:
            for item in layout['furniture_placement']:
                style_str = " ".join(style_attributes) if style_attributes else ""
                search_query = f"{style_str} {item['description']}".strip()

                try:
                    image_url = self.search_furniture_image(search_query)
                    item['image_url'] = image_url
                except Exception as e:
                    print(f"Error fetching image: {e}")
                    item['image_url'] = None

      return layout




    def parse_room_request(self, room_request):
      """
      Parse a descriptive room request into room type and style attributes

      Args:
          room_request (str): User's room request description (e.g., "modern study room that is light")

      Returns:
          tuple: (room_type, style_attributes)
      """
      # Basic room types to check for
      base_room_types = [
          "bedroom", "living room", "kitchen", "bathroom", "dining room",
          "office", "study", "hallway", "entryway", "balcony", "patio",
          "nursery", "playroom", "garage", "basement", "attic", "studio"
      ]

      # Common style descriptors
      style_descriptors = [
          "modern", "contemporary", "traditional", "rustic", "industrial",
          "minimalist", "scandinavian", "bohemian", "vintage", "retro",
          "classic", "elegant", "luxurious", "cozy", "warm", "cool",
          "bright", "dark", "light", "colorful", "neutral", "wooden",
          "metal", "glass", "leather", "eco-friendly", "sustainable"
      ]

      # Clean and lowercase the input
      room_request_lower = room_request.lower()

      # Find the base room type
      found_room_type = None
      for room_type in base_room_types:
          if room_type in room_request_lower:
              found_room_type = room_type
              break

      # If no base room type is found, check for "room" and use preceding word(s)
      if not found_room_type and "room" in room_request_lower:
          parts = room_request_lower.split("room")[0].strip().split()
          if parts:
              # Take the last word before "room" as potential room type
              candidate = parts[-1] + " room"
              if candidate not in ["a room", "the room", "my room", "this room"]:
                  found_room_type = candidate

      # Default to "room" if still not found
      if not found_room_type:
          found_room_type = "room"

      # Extract style attributes
      style_attributes = []
      for descriptor in style_descriptors:
          if descriptor in room_request_lower:
              style_attributes.append(descriptor)

      return found_room_type, style_attributes


    def suggest_room_layout(self, room_type, room_size):
        """
        Suggest a room layout based on user preferences

        Args:
            room_type (str): Type of room (bedroom, living room, kitchen, etc.)
            room_size (dict): Room dimensions (width, length in meters)

        Returns:
            dict: Suggested room layout with furniture placement
        """
        suitable_items = self.get_suitable_furniture(room_type)
        if not suitable_items:
            print(f"Warning: No furniture items found for room type '{room_type}'. Using default items.")
            suitable_items = self.get_default_furniture(room_type)

        layout = self.create_layout(room_size, suitable_items)
        return layout

    def get_suitable_furniture(self, room_type):
      """
      Get suitable furniture items based on room type using a more robust approach
      that handles a list-based furniture_descriptions structure
      """
      # Step 1: Find relevant scenes from image descriptions
      relevant_scenes = []
      room_type = room_type.lower()
      room_type_variations = [room_type, room_type.replace(" ", ""), f"master {room_type}"]

      for scene, desc_dict in self.img_to_description.items():
          if isinstance(desc_dict, dict) and "desc" in desc_dict:
              desc = desc_dict["desc"]
              if isinstance(desc, str):
                  desc_lower = desc.lower()
                  if any(variation in desc_lower for variation in room_type_variations):
                      relevant_scenes.append(scene)

      print(f"Relevant scenes for '{room_type}': {relevant_scenes}")

      # Step 2: Extract product IDs from the scene filenames
      product_ids = []
      for scene in relevant_scenes:
          # Extract the product ID from the filename
          filename = os.path.basename(scene)
          product_id = os.path.splitext(filename)[0]
          product_ids.append(product_id)

      print(f"Extracted product IDs: {product_ids[:5]}...")  # Show first 5 for debugging

      # Step 3: Handle furniture_descriptions as a list
      matched_items = []

      # Determine the structure of furniture_descriptions
      if isinstance(self.furniture_descriptions, list):
          print("Processing furniture_descriptions as a list")

          # Approach 1: If it's a list of dictionaries with 'id' and 'description' fields
          for item in self.furniture_descriptions:
              if isinstance(item, dict) and 'id' in item and 'description' in item:
                  item_id = item['id']
                  item_desc = item['description']

                  # Direct match by ID
                  if any(pid == item_id for pid in product_ids):
                      matched_items.append({
                          'id': item_id,
                          'description': item_desc,
                          'dimensions': self.get_item_dimensions(item_id)
                      })
                      continue

                  # Text-based match for room type
                  if isinstance(item_desc, str) and room_type in item_desc.lower():
                      matched_items.append({
                          'id': item_id,
                          'description': item_desc,
                          'dimensions': self.get_item_dimensions(item_id)
                      })

          # If the above didn't work (no matches), try other list structures
          if not matched_items and len(self.furniture_descriptions) > 0:
              # Try first item to determine structure
              first_item = self.furniture_descriptions[0]
              print(f"First item type: {type(first_item)}")

              # If items are strings or tuples or other structure, handle accordingly
              # This is a flexible approach that can adapt to different list structures
              for i, item in enumerate(self.furniture_descriptions):
                  item_id = f"item_{i}"  # Generate an ID if none exists
                  item_desc = str(item)  # Convert item to string if it's not already

                  # Check if the item contains any mention of the room type
                  if room_type in item_desc.lower():
                      matched_items.append({
                          'id': item_id,
                          'description': item_desc,
                          'dimensions': self.get_item_dimensions(item_id)
                      })
      else:
          print("furniture_descriptions is not a list, it's a", type(self.furniture_descriptions))
          # Add additional handling for other types if needed

      # If still no matches, fall back to default furniture
      if not matched_items:
          print(f"No matches found in furniture_descriptions, using default furniture for {room_type}")
          return self.get_default_furniture(room_type)

      print(f"Found {len(matched_items)} matched items for {room_type}")
      return matched_items[:10]  # Return up to 10 matched items
    def get_item_dimensions(self, item_id):
      """
      Get the dimensions of a furniture item, handling different data structures

      Args:
          item_id (str): The ID of the furniture item

      Returns:
          dict: Dimensions of the item (width, length, height)
      """
      # Try to get dimensions from product_dimensions dictionary
      if hasattr(self, 'product_dimensions') and isinstance(self.product_dimensions, dict):
          if item_id in self.product_dimensions:
              product_info = self.product_dimensions[item_id]
              if isinstance(product_info, dict) and 'dimensions' in product_info:
                  return product_info['dimensions']

      # Try to find dimensions in furniture_descriptions if it's a list of dictionaries
      if isinstance(self.furniture_descriptions, list):
          for item in self.furniture_descriptions:
              if isinstance(item, dict) and 'id' in item and item['id'] == item_id:
                  if 'dimensions' in item:
                      return item['dimensions']
                  elif 'width' in item and 'length' in item:
                      return {
                          'width': item.get('width', 0.6),
                          'length': item.get('length', 0.6),
                          'height': item.get('height', 0.8)
                      }

      # Default dimensions if not found
      return {"width": 0.6, "length": 0.6, "height": 0.8}

    def get_default_furniture(self, room_type):
        """
        Get default furniture items for a room type
        """
        default_items = {
            "bedroom": [
                {"id": "bed1", "description": "Queen-sized bed", "dimensions": {"width": 1.6, "length": 2.0, "height": 0.5}},
                {"id": "nightstand1", "description": "Wooden nightstand", "dimensions": {"width": 0.5, "length": 0.5, "height": 0.6}},
            ],
            "living room": [
                {"id": "sofa1", "description": "3-seater sofa", "dimensions": {"width": 2.0, "length": 0.9, "height": 0.8}},
                {"id": "coffee_table1", "description": "Glass coffee table", "dimensions": {"width": 1.2, "length": 0.6, "height": 0.4}},
                {"id": "tv_stand1", "description": "Modern TV stand", "dimensions": {"width": 1.5, "length": 0.4, "height": 0.6}},
            ],
            "kitchen": [
                {"id": "table1", "description": "Dining table", "dimensions": {"width": 1.8, "length": 0.9, "height": 0.75}},
                {"id": "chair1", "description": "Dining chair", "dimensions": {"width": 0.5, "length": 0.5, "height": 0.9}},
            ],
        }
        return default_items.get(room_type, [])

    def create_layout(self, room_size, furniture_items):
        """
        Create a room layout with furniture placement

        Args:
            room_size (dict): Room dimensions (width, length in meters)
            furniture_items (list): List of furniture items

        Returns:
            dict: Room layout with furniture placement
        """
        sorted_items = sorted(
            furniture_items,
            key=lambda x: x['dimensions']['width'] * x['dimensions']['length'],
            reverse=True
        )

        if not sorted_items:
            print("Warning: No suitable furniture items found. Returning an empty layout.")
            return {
                'room_dimensions': room_size,
                'furniture_placement': []
            }

        layout = {
            'room_dimensions': room_size,
            'furniture_placement': []
        }

        wall_positions = [
            {'x': 0, 'y': 0, 'wall': 'bottom-left'},
            {'x': 0, 'y': room_size['length'] - sorted_items[0]['dimensions']['length'], 'wall': 'top-left'},
            {'x': room_size['width'] - sorted_items[0]['dimensions']['width'], 'y': 0, 'wall': 'bottom-right'},
            {'x': room_size['width'] - sorted_items[0]['dimensions']['width'],
             'y': room_size['length'] - sorted_items[0]['dimensions']['length'], 'wall': 'top-right'},
        ]

        center_position = {
            'x': room_size['width'] / 2 - sorted_items[0]['dimensions']['width'] / 2,
            'y': room_size['length'] / 2 - sorted_items[0]['dimensions']['length'] / 2,
            'wall': 'center'
        }

        for i, item in enumerate(sorted_items):
            if i < len(wall_positions):
                position = wall_positions[i]
            else:
                offset = (i - len(wall_positions)) * 0.3
                position = {
                    'x': center_position['x'] + offset,
                    'y': center_position['y'] + offset,
                    'wall': 'center'
                }

            layout['furniture_placement'].append({
                'item_id': item['id'],
                'description': item['description'],
                'position': position,
                'dimensions': item['dimensions'],
                'rotation': 0
            })

        return layout

# Example usage with dynamic user input
def main():
    data_path = "/content/drive/MyDrive/Datasets"
    ai_system = InteriorDesignAI(data_path)

    print("Interior Design AI System")
    print("------------------------")
    print("You can enter room types with style descriptors like 'modern study room that is light'")

    # Get user input for room type and dimensions
    room_request = input("Enter your room description: ")
    width = float(input("Enter the room width (in meters): "))
    length = float(input("Enter the room length (in meters): "))

    # Suggest a room layout with style considerations
    room_layout = ai_system.suggest_room_layout_with_style(
        room_request=room_request,
        room_size={"width": width, "length": length},
    )

    # Print the suggested layout
    print("\nSuggested Room Layout:")
    print(json.dumps(room_layout, indent=2))

    # Print furniture with style scores if available
    print("\nFurniture Items (with style relevance):")
    for item in room_layout['furniture_placement']:
        style_score = item.get('style_score', 'N/A')
        print(f"- {item['description']} (Style match: {style_score if isinstance(style_score, float) else 'N/A'})")

if __name__ == "__main__":
    main()

!git init

!git add .
!git commit -m "Add project code and initial files"

